1.
局部变量除形参外，需显式初始化。
2.
结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。
:::info
==说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量==
:::
3.
short s1 = 10;
//s1 = s1 + 2;//编译失败
:::info
==s1 += 2;//结论：不会改变变量本身的数据类型==
:::
4.
检查是否是类的对象 “Hello” instanceof String 
5.
else 结构是可选的
6.
:::info
==如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。==
:::
7.
:::info
==switch结构中的表达式，只能是如下的6种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)④ case 之后只能声明常量。不能声明范围。==
==:::==
8.
补充:衡量一个功能代码的优劣：高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）
9.
:::info
==数组元素是char型：0或'\u0000'，而非'0'==
:::
10.
int[] arr[] = {{1,2,3},{4,5},{6,7,8}};//类型推断
11.
JVM
虚拟机栈，即为平时提到的栈结构。
:::info
==1.我们将局部变量存储在栈结构中==
==2.堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。==
==3.补充：对象的属性（非static的）加载在堆空间中。==
:::
方法区：类的加载信息、常量池、静态域
12.
可变个数形参的方法
12.1.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载，换句话说，二者不能共存。	
12.2.可变个数形参在方法的形参中，必须声明在末尾
1.2.3.可变个数形参在方法的形参中,最多只能声明一个可变形参。
13.
13.1. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
13.2. 如果使用的类或接口是本包下定义的，则可以省略import结构
13.3. 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式。	
14.
使用"xxx._"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入（_表示类或接口）

15. import static:导入指定类或接口中的静态结构:属性或方法。 
    16.
    封装性
    我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
    17.
    封装性体现三：
    单例模式（将构造器私有化）
    18.
    4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
    修饰类的话，只能使用：缺省、public
    19.
    一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
    20.
    :::info
    ==1.属性赋值顺序==
    ==总结：属性赋值的先后顺序==
    ==①默认初始化==
    ==②显式初始化/⑤在代码块中赋值==
    ==③构造器中初始化==
    ==④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值==
    ==执行的先后顺序：① - ② / ⑤(看谁在前面) - ③ - ④==
    :::
    21.
    JavaBean的使用
    所谓JavaBean，是指符合如下标准的Java类：
    :::info
    ==1.类是公共的==
    ==2.一个无参的公共的构造器（反射造对象用）==
    ==3.有属性，且有对应的get、set方法==
    :::
    22.
    我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
    23.
    this调用构造器：
    :::info
    "==this(形参列表)"必须声明在当前构造器的首行==
    :::
    24.
    24.1.父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
    24.2.父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
     ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
    25.
> ==对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”。==

> ==对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。== 

26.
> ==26.1.当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。==

> ==26.2.当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。==

27.
:::info
==针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现==
==**this(形参列表)**用于调用当前类的其他构造函数。它必须作为构造函数的第一条语句出现，并且只能在构造函数内部使用。通过**this**关键字调用其他构造函数可以在一个构造函数中重用代码，提高代码的可维护性。==
==**super(形参列表)**用于调用父类的构造函数。它也必须作为构造函数的第一条语句出现，并且只能在子类的构造函数内部使用。通过**super**关键字调用父类的构造函数可以实现子类对父类构造函数的初始化操作。==
:::
28.
JVM
:::info
==创建子类的对象，在堆空间中，就会加载所父类中声明的属性。==
==正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。==
:::
29.
:::info
==虽然创建子类对象时，调用了父类的构造器，==
==但是自始至终就创建过一个对象，即为new的子类对象(没new不算创建对象)==
:::
30.
多态性的使用：虚拟方法调用
对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）
31.
子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，
32.
如何才能调用子类特的属性和方法？使用向下转型。
33.
3.1 谈谈你对多态性的理解？
① 实现代码的通用性。
③ 抽象类、接口的使用体现了多态性。（抽象类、接口不能实例化）

1. 匿名类实例化：通过创建一个匿名类的实例来实例化接口。这种方式通常用于在需要临时实现接口的场景中。例如：
```java
interface MyInterface {
    void myMethod();
}

MyInterface obj = new MyInterface() {
    public void myMethod() {
        // 实现接口方法的具体逻辑
    }
};
```
34.
JVM
:::info
==静态变量内存解析：==
==jdk6及之前，存放在方法区。jdk7及之后，存放在堆空间==
:::
35.
:::info
==接口与接口之间可以继承，而且可以多继承==
:::
36.
:::info
==知识点1：接口中定义的静态方法，只能通过接口来调用。==
==可以通过接口名称来调用静态方法，但静态方法不会被继承到实现类中==
:::
知识点2：通过实现类的对象，可以调用接口中的默认方法。
37.
:::info
==创建内部类的实例==
:::

```shell
//创建非静态的Bird内部类的实例(非静态的成员内部类):
//通过调用内部类
Person.Bird bird = new Person.Bird();//错误的
应该用对象去new
Person p = new Person();
Person.Bird bird = p.new Bird();
```
38.
:::info
==内部类调外部属性==
:::
非静态成员内部类
内部类调外部类：
1，外部类.this.属性
2，外部类实例.属性
:::info
==外部类的属性访问是通过创建实例对象来进行的，而不是直接通过外部类名来访问。这是因为属性属于对象的状态，而不是类级别的信息。外部类.this.属性==
:::

```shell
	class Bird{
		String name = "杜鹃";
		public void display(String name){
			System.out.println(name);//方法的形参
			System.out.println(this.name);//内部类的属性
			System.out.println(Person.this.name);//外部类的属性
		Person.this.eat();
		}
	}
}
```
39.
局部内部类的使用：
匿名/有名实现类		X	实现类的有名/匿名对象	
返回一个实现了Comparable接口的类的对象
	public Comparable getComparable(){
//接口实现类：MyComparable
		  //创建一个实现了Comparable接口的类:局部内部类
:::info
		==//方式1：提供了接口的实现类的有名对象==
:::

```java
//		class MyComparable implements Comparable{
//			@Override
//			public int compareTo(Object o) {
//				return 0;
//			}	
//		}
MyComparable m=new MyComparable
    //		return m;
```
:::info
		==//方式2：提供了接口的实现类的匿名对象==
:::

```java
//		class MyComparable implements Comparable{
//			@Override
//			public int compareTo(Object o) {
//				return 0;
//			}	
//		}
//		return new MyComparable();
```
:::info
==//方式3：接口的一个匿名实现类的有名对象==
:::

```java
Comparable c = new Comparable(){
    @Override
    public int compareTo(Object o) {
        return 0;
    }	
};
return c;
```
:::info
		==//方式4：接口的一个匿名实现类的匿名对象==
:::

```java
		return new Comparable(){
			@Override
			public int compareTo(Object o) {
				return 0;
			}	
		};
```
	}
40.
```java
public class Outer {
    public void outerMethod() {
        final int num = 10; // 局部变量 num

        class Inner {
            public void innerMethod() {
                System.out.println(num); // 引用外部方法的局部变量 num
            }
        }

        Inner inner = new Inner();
        inner.innerMethod();
    }
}
```
:::info
==在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。==
==这是因为当 **innerMethod()** 方法被调用时，可能会出现以下情况：==

- ==**outerMethod()** 方法已经执行完毕，**num** 变量已经销毁。==
- ==**innerMethod()** 方法可能在 **outerMethod()** 方法之外的地方被调用。==

==为了解决这个问题，Java 要求 **num** 声明为 **final**，以确保其值在 **innerMethod()** 方法被调用时是固定的，不会发生变化。==
==**final** 关键字的作用主要有两个方面：==

1. ==不可修改：使用 **final** 关键字修饰的变量表示它的值不能被修改。这意味着一旦变量被赋予初始值，就无法再改变它的值。这样做的目的是为了保持代码的可预测性和安全性。==
2. ==延长生命周期：在局部内部类中引用外部方法的局部变量时，需要确保该变量在内部类实例对象存在期间保持一致。因为方法执行完毕后，方法中的局部变量通常会被销毁。但是，如果局部变量被内部类引用，为了保证内部类实例对象正常访问该变量，Java 编译器要求将其声明为 **final**。这样做可以延长局部变量的生命周期，使其在内部类实例对象存在期间保持有效。==
:::
41.
总结：
:::info
==成员内部类和局部内部类，在编译以后，都会生成字节码文件。==
==格式：成员内部类：外部类$内部类名.class==
==局部内部类：外部类$数字内部类名.class==
:::
42.
:::info
==如果枚举类中只一个对象，则可以作为单例模式的实现方式。==
:::
43.
:::info
==values():返回所有的枚举类对象构成的数组==
:::
44.
valueOf(String objName):返回枚举类中对象名是objName的对象。

